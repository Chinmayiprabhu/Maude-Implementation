load prelude.maude

fmod ELEM is
    including QID .
    sort Elem .
    op eRROr : -> Elem .
    subsort Qid < Elem .
endfm

view Elem from TRIV to ELEM is
    sort Elt to Elem .
endv

fmod ELEMSET is
    including ELEM .
    including SET{Elem} .

    sorts ElemSet NeElemSet .
    subsort Set{Elem} < ElemSet .
    subsort NeSet{Elem} < NeElemSet .
endfm

fmod NODE is
    including ELEM .
    including ELEMSET .
    sort Node .
    op _-->_ : Elem Elem -> Node [ctor] .
    op _-/->_ : Elem Elem -> Node [ctor] .

endfm

**** I defined a new NODELIST because cmb/mb did not like assoc in the constructor .
fmod NODELIST is
    including NODE .
    sort  NeNodeList .

    op root : Elem -> NeNodeList [ctor] .
    op __ : NeNodeList Node -> NeNodeList [ctor] .

endfm

fmod TREE is
    including NODELIST .
    sort BrTree Tree .
    subsort   Tree < BrTree < NeNodeList .
    vars el el1 el2 : Elem .
    var els : ElemSet .
    var nd : Node .
    var ndl : NeNodeList .


    op _in_ : Elem NeNodeList -> Bool .
    eq el in (root(el)) = true .
    eq el in (ndl (el1 --> el2) )  = (el == el2) or (el in ndl) .
    eq el in (ndl (el1 -/-> el2) )  = (el == el2) or (el in ndl) .
    eq el in ndl = false [owise] .


   cmb ndl (el1 --> el2) : Tree if (el1 in ndl) and  (not (el2 in ndl)) and ndl :: Tree .
   mb root(el) : Tree .

   cmb ndl (el1 --> el2) : BrTree if (el1 in ndl) and  (not (el2 in ndl)) and ndl :: BrTree .
   cmb ndl (el1 -/-> el2) : BrTree if (el1 in ndl) and  (not (el2 in ndl)) and ndl :: Tree .
   cmb ndl (el1 -/-> el2) : BrTree if (el1 in ndl) and  (not (el2 in ndl)) and ndl :: BrTree .




   op existPath : Elem Elem NeNodeList -> Bool .
   eq existPath(el1 , el2 , ndl (el1 --> el2) ) = true .
   eq existPath(el1 , el2 , ndl (el --> el2) ) = (el == el1) or existPath(el1 , el , ndl) .
   eq existPath(el1 , el2 , ndl (el --> el2) ) = (el =/= el1) and existPath(el1 , el2, ndl) .
   eq existPath(el1 , el2 , ndl nd ) =  existPath(el1 , el2, ndl) .
   eq existPath(el1 , el2 , ndl) = false [owise] .



   *** The Parent function
   op  parent : Elem NeNodeList -> Elem .

   eq  parent(el, root(el1)) = eRROr .
   ceq parent(el, ndl ( el1 --> el2 ))  = el1 if (el == el2) .
   ceq parent(el, ndl ( el1 --> el2 ))  = parent(el,ndl)  if (el =/= el2) .

   *** The childof function
   op  childof : Elem NeNodeList -> ElemSet .
   ceq childof(el  , ndl(el1 --> el2 )) = el2 if ( el == el1 ) and not ( el1 in ndl) .
   ceq childof(el  , ndl(el1 --> el2 )) = el2 childof(el  , ndl(el1 --> el2 ) if ( el == el1 ) and ( el1 in ndl) .
   ceq childof(el  , ndl(el1 --> el2 )) = childof( ndl ( el --> el1)) if ( el =/= el1) and ( el1 in ndl) .


endfm

view Tree from TRIV to TREE is
    sort Elt to Tree .
endv

fmod TREESET is
    including TREE .
    including SET{Tree} .

    sorts TreeSet NeTreeSet .
    subsort Set{Tree} < TreeSet .
    subsort NeSet{Tree} < NeTreeSet .
endfm



fmod FILTERTREE is
  including TREE .
  including ELEMSET .
  including TREESET .
  sort FamilyTree .
  *** sort leavesSet .

  op <_:_> : TreeSet Elem -> FamilyTree [ctor] .

  *** op <_;_> : TreeSet ElemSet -> leavesSet [ctor] .

  vars el el1 el2 : Elem .
  var els els1  : ElemSet .
  var neels : NeElemSet .
  var nd : Node .
  var t : Tree .
  var bt : BrTree .
  var ndl : NeNodeList .



 ***(
  given a node which is a subtree T, it return a pair where the first part
  is the original tree T and the second part is the branch from the given element .
  )
  op _with_ : Elem Tree -> FamilyTree .
  eq el with t = <  branch(el,t) : el > .



  ***(
  given a node which is a subtree T, it return a pair where the first part
  is the broken tree from T and the second part is the set of branches
  that were broken .
  )
  op (_:\:_)with_  : Elem  NeElemSet Tree -> FamilyTree .
  eq (el :\: els) with t = < break(els,t) : el > .

  **** given a node it returns a branch from such node .
  op branch : Elem Tree -> Tree .
  eq branch(el , root(el))  = root(el) .
  eq branch(el , ndl (el1 --> el))   = root(el) .
  eq branch(el , ndl (el --> el2))   = branch(el , ndl)  (el --> el2)  .
  ceq branch(el , ndl (el1 --> el2)) = branch(el , ndl)  (el1 --> el2) if existPath( el, el1, ndl (el1 --> el2)) .
  ceq branch(el , ndl (el1 --> el2))  = branch(el , ndl)  if existPath( el, el1, ndl (el1 --> el2)) == false .
  eq branch (el , ndl) = root(eRROr) [owise] .

 *** ( here I wanted to find out the total leaves of the main/original tree)
  op leaves : Tree -> ElemSet .
  ceq leaves (ndl( el1 --> el2)) = el2 , (leaves(ndl(el1 --> el2 ))) if (el1 in ndl) and (not( el2 in ndl)) .


***( With this operation , we can find the broken tree leaves by removing the elements and children set of those element one way to prune the tree)
  op brleaves : BrTree -> ElemSet .
  eq brleaves(break( els , t)) =  leaves (t) - ( els, childof(els)) .

  *** overload the branch to work over sets of elements
  op branch : ElemSet Tree -> TreeSet .
  eq branch(empty , t) = empty .
  eq branch((els, el) , t) =  branch(els , t) , branch(el , t)  .

  *** break one of the constructors so that the tree becomes a broken tree
  op break : Elem Tree -> BrTree .
  eq break(el, root(el)) = root(el) .
  eq break(el, ndl (el1 --> el))   = ndl (el1 -/-> el) .
  ceq break (el, ndl (el1 --> el2)) = break(el, ndl) (el1 --> el2) if el =/= el2 .

  *** overload the break function to work over sets
  op break : ElemSet BrTree -> BrTree .
  eq break(empty, bt) = bt .
  eq break ((els,el), bt) = break(els, break(el,bt)) .

***( These are set minus operation)

***(op remove : Elem ElemSet -> ElemSet .
eq remove(el, (el)) = empty .
eq remove(el, (el, els)) = remove(el, els) .
eq remove(el, els) = els [owise] .

op setminus : ElemSet ElemSet -> ElemSet .
ceq (els1 - el, els) = els1 )


  op Add : Elem ElemSet -> ElemSet .
  eq Add(el, empty) = el .
  eq Add(el, els) = els, el .

  op _-_ : ElemSet ElemSet -> ElemSet [ctor gather (E e)] .
  eq empty - els = empty .
  eq els - empty = els .
  eq els - neels = setminus(els, neels, empty) .

  op setminus : ElemSet ElemSet ElemSet -> ElemSet .
  eq setminus((el,els), els1, A) = if el in els1 then A else Add(el, A) fi .
  eq setminus((el, els), els1, A) = setminus(els, els1, setminus(el, els1, A)) .


endfm

fmod TEST is
  including FILTERTREE .
  ops Hlthcr Admin Hlthwrkr marketing Billing Doc HAss Phar Spcl GP Nur LabAss Gynac DT cleaner : -> Elem .

  op tr : -> Tree .
  eq tr = root(Hlthcr) (Hlthcr --> Admin)  (Hlthcr --> Hlthwrkr) (Admin --> marketing) (Admin --> Billing)
  (Hlthwrkr --> Doc) (Hlthwrkr --> Phar)(Hlthwrkr --> HAss) (Doc --> Spcl) ( Doc --> GP ) (HAss --> Nur)
  (HAss --> LabAss) (Spcl --> Gynac) (Spcl --> DT) .

endfm





*** red root(Hlthcr) (Hlthcr --> Admin)  (Hlthcr --> Hlthwrkr) (Admin --> marketing) . ---> Tree
*** red root(Hlthcr) (Hlthcr --> Admin)  (Hlthcr --> Hlthwrkr) (Admin -/-> marketing) . ---> BrTree
*** red root(Hlthcr) (Hlthcr --> Admin)  (Doc -/-> Spcl) . ---> NeNodeList
*** red (root(Hlthcr) (Hlthcr --> Admin)  (Hlthcr --> Hlthwrkr) (Admin -/-> marketing)) , (root(Hlthcr) (Hlthcr --> Admin)  (Doc -/-> Spcl)) . -->  [TreeSet,NeTreeSet,NeNodeList]
*** red break ( (Doc, HAss) , tr ) .
*** red existPath ( Admin , DT , tr ) . --> false
*** red existPath(Hlthcr ,  LabAss , tr ) . --> True
**** red  existPath(a,d,tr) .
*** red branch ( Admin , tr ) .
*** red branch ( (marketing,Doc)  , tr ) .-->NeSet{Tree}: root(marketing), root(Doc) Doc --> Spcl Doc --> GP Spcl --> Gynac Spcl --> DT
*** red break ( Doc , tr ) .--> BrTree: root(Hlthcr) Hlthcr --> Admin Hlthcr --> Hlthwrkr Admin --> marketing Admin --> Billing Hlthwrkr -/->
    *** Doc Hlthwrkr --> Phar Hlthwrkr --> HAss Doc --> Spcl Doc --> GP HAss --> Nur HAss --> LabAss Spcl --> Gynac Spcl
    *** --> DT
*** red break ( ( Admin , Spcl ) , tr ) . --> BrTree: root(Hlthcr) Hlthcr -/-> Admin Hlthcr --> Hlthwrkr Admin --> marketing Admin --> Billing Hlthwrkr -->
    *** Doc Hlthwrkr --> Phar Hlthwrkr --> HAss Doc -/-> Spcl Doc --> GP HAss --> Nur HAss --> LabAss Spcl --> Gynac Spcl --> DT

*** red ( Hlthwrkr :\: LabAss ) with tr .
*** red ( Hlthwrkr :\: LabAss, Billing ) with tr . --> [FamilyTree]: < root(Hlthcr) Hlthcr --> Admin Hlthcr --> Hlthwrkr Admin --> marketing Admin -/-> Billing
        *** Hlthwrkr --> Doc Hlthwrkr --> Phar Hlthwrkr --> HAss Doc --> Spcl Doc --> GP HAss --> Nur HAss -/-> LabAss Spcl -->
        *** Gynac Spcl --> DT : Hlthwrkr >

*** red Spcl with tr . --> FamilyTree: < root(Spcl) Spcl --> Gynac Spcl --> DT : Spcl >
