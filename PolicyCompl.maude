load prelude.maude
load taxonomynew.maude


fmod POLICY is
  including FILTERTREE .
  including ACCESS .
  including TEST .
  vars el  el1  el2 : Elem .
  var els els1  : ElemSet .
  var R : Nat .
  var E  A  P  L  : ElemSet .
  var P1  P2  P3 : Policy .
  var neels : NeElemSet .
  var t : Tree .
  var bt : BrTree .
  var ndl : NeNodeList .
  sort Policy .
  op ( _ , _ , _ , _ , _ ) : Set{Elem} Set{Elem} Set{Elem} Nat Set{Elem} -> Policy [ctor] .
  mb ( (el :\: els) with t , ((el & els)) , (el :\: els) with t, R , (el :\: els) with t ) :  Policy  .
  mb ( (el :\: els) with t , ((el \\ els)) , (el :\: els) with t, R , (el :\: els) with t ) :  Policy  .

  op entity_ : Policy -> ElemSet .
  eq entity(E , A , P , R , L) = (E) .

  op Actions_ : Policy -> ElemSet .
  eq Actions(E , A , P , R , L) = (A) .

  op purpose_ : Policy -> ElemSet .
  eq purpose(E , A , P , R , L) = P .

  op Ret_ : Policy -> Nat .
  eq Ret(E , A , P , R , L) = R .

  op Loc_ : Policy -> ElemSet .
  eq Loc(E , A , P , R , L) = L .

endfm

view Policy from TRIV to POLICY is
    sort Elt to Policy .
endv

fmod POLICYSET is
    including POLICY .
    including SET{Policy} .

    sorts PolicySet NePolicySet .
    subsort Set{Policy} < PolicySet .
    subsort NeSet{Policy} < NePolicySet .


endfm

fmod POLICY-LIST is
  including POLICY .

  sort NePolicyList .
  subsort Policy < NePolicyList .
  op singlepolicy : Policy -> NePolicyList [ctor] .
  op [ _ , _ ] : NePolicyList Policy -> NePolicyList [ctor] .

endfm

fmod COMPLIANCE is
including POLICY .
including ELEMSET .
including POLICYSET .
including POLICY-LIST .
including SET{Elem} .
including LIST{Policy} .
including NAT .

vars P1  P2  P3  P4 : Policy .
var Ps Ps1 :  NePolicyList .
vars els els1 : ElemSet .
vars R1  R2 : Nat .

op entityjoin : NePolicyList -> ElemSet .
eq entityjoin(P1,,P2) = Join(entity(P1), entity(P2)) .
eq entityjoin(P1,,P2,,Ps) = Join((Join(entity(P1), entity(P2))) , entity(Ps)) .
op entityinter : NePolicyList -> ElemSet .
eq entityinter(P1,,P2) = Inter(entity(P1), entity(P2)) .
eq entityinter(P1,,P2,,Ps) = Inter((Inter(entity(P1), entity(P2))) , entity(Ps)) .


op actionjoin : NePolicyList -> ElemSet .
eq actionjoin(P1,,P2) = Join(Actions(P1), Actions(P2)) .
eq actionjoin(P1,,P2,,Ps) = Join((Join(Actions(P1), Actions(P2))) , Actions(Ps)) .
op actioninter : NePolicyList -> ElemSet .
eq actioninter(P1,,P2) = Inter(Actions(P1), Actions(P2)) .
eq actioninter(P1,,P2,,Ps) = Inter((Inter(Actions(P1), Actions(P2))) , Actions(Ps)) .


op purposejoin : NePolicyList -> ElemSet .
eq purposejoin(P1,,P2) = Join(purpose(P1), purpose(P2)) .
eq purposejoin(P1,,P2,,Ps) = Join((Join(purpose(P1), purpose(P2))) , purpose(Ps)) .
op purposeinter : NePolicyList -> ElemSet .
eq purposeinter(P1,,P2) = Inter(purpose(P1), purpose(P2)) .
eq purposeinter(P1,,P2,,Ps) = Inter((Inter(purpose(P1), purpose(P2))) , purpose(Ps)) .


op locationjoin : NePolicyList -> ElemSet .
eq locationjoin(P1,,P2) = Join(Loc(P1), Loc(P2)) .
eq locationjoin(P1,,P2,,Ps) = Join((Join(Loc(P1), Loc(P2))) , Loc(Ps)) .
op locationinter : NePolicyList -> ElemSet .
eq locationinter(P1,,P2) = Inter(Loc(P1), Loc(P2)) .
eq locationinter(P1,,P2,,Ps) = Inter((Inter(Loc(P1), Loc(P2))) , Loc(Ps)) .

op _subseq_ : Policy Policy -> Bool .
eq P1 subseq P2 = P1 subset P2 .

op _subse_ : Set{Elem} Set{Elem} -> Bool .
eq els subse els1 = els subset els1 .

op _less_ : Nat Nat -> Bool .
eq R1 less R2 = R1 < R2 .

op Inter : Set{Elem} Set{Elem} -> Set{Elem} .
eq Inter (els, els1 ) = intersection (els , els1) .

op Join : Set{Elem} Set{Elem} -> Set{Elem} .
eq Join ( els , els1) = union(els, els1) .

op mini : Nat Nat -> Nat .
ceq mini( R1, R2) = R1 if (R1 < R2) .
ceq mini( R1, R2) = R2 if (R2 < R1) .

op _\C_ : Policy Policy -> Bool .
ceq P1 \C P2 = true if entity(P1) subse entity(P2) /\ Actions(P1) subse Actions(P2) /\  purpose(P1) subse purpose(P2) /\ Ret(P1) <= Ret(P2) /\ Loc(P1) subse Loc (P2) .
eq P1 \C P2 = false [owise] .

op (_,,_) : NePolicyList  NePolicyList  -> NePolicyList [ctor assoc ] .

op closure : NePolicyList -> NePolicyList .
eq closure (P1,,P2) =((entityjoin(P1,,P2),actioninter(P1,,P2),purposeinter(P1,,P2), min( Ret(P1),Ret(P2)),locationinter(P1,,P2)),,
(entityinter(P1,,P2),actionjoin(P1,,P2),purposeinter(P1,,P2), min( Ret(P1),Ret(P2)),locationinter(P1,,P2)),,
(entityinter(P1,,P2),actioninter(P1,,P2),purposejoin(P1,,P2), min( Ret(P1),Ret(P2)),locationinter(P1,,P2)),,
(entityinter(P1,,P2),actioninter(P1,,P2),purposeinter(P1,,P2), min( Ret(P1),Ret(P2)),locationjoin(P1,,P2))) .
eq closure (P1,,P2,,Ps) =((entityjoin(P1,,P2,,Ps),actioninter(P1,,P2,,Ps),purposeinter(P1,,P2,,Ps), min((min(Ret(P1),Ret(P2))),Ret(Ps)),locationinter(P1,,P2,,Ps)),,
(entityinter(P1,,P2,,Ps),actionjoin(P1,,P2,,Ps),purposeinter(P1,,P2,,Ps), min((min(Ret(P1),Ret(P2))),Ret(Ps)),locationinter(P1,,P2,,Ps)),,
(entityinter(P1,,P2,,Ps),actioninter(P1,,P2,,Ps),purposejoin(P1,,P2,,Ps), min((min(Ret(P1),Ret(P2))),Ret(Ps)),locationinter(P1,,P2,,Ps)),,
(entityinter(P1,,P2,,Ps),actioninter(P1,,P2,,Ps),purposeinter(P1,,P2,,Ps), min((min(Ret(P1),Ret(P2))),Ret(Ps)),locationjoin(P1,,P2,,Ps))) .



***eq closure(P1,,P2,,Ps) = closure((closure(P1,,P2)),,Ps) .
***This function helps to chceking compliance rule between policy sets
op complysubset : Policy NePolicyList -> NePolicyList .
ceq complysubset( P1, P2) = P2  if ( not (Inter(entity(P1), entity(P2)) == empty)) .
ceq complysubset( P1, (P2,,Ps)) =  (P2 ,, complysubset( P1, Ps)) if (complysubset( P1, P2) == P2) .
eq complysubset( P1, (P2,,Ps)) = complysubset( P1, Ps) .
eq complysubset( P1, P2) = empty [owise] .

***function for compliance between two policy entries
op complyrule1  : Policy NePolicyList -> Bool .
eq complyrule1(P1, P2 ) =  if (P1 \C P2) then true else false fi .
eq complyrule1(P1, (P2 ,, Ps)) = if (P1 \C P2) then true else complyrule1(P1 ,Ps ) fi .
eq complyrule1(P1, Ps ) = false .
***total compliance with policy set
op complywithset : Policy NePolicyList -> Bool .
ceq complywithset(P1, P2) = true if P1 \C P2 .
ceq complywithset( P1, (P2,,Ps)) = true if complyrule1(P1 , closure(complysubset(P1, (P2,,Ps)))) == true .
ceq complywithset( P1, (P2,,Ps)) = true if complyrule1(P1, (P2 ,, Ps)) == true .
eq complywithset( P1, (P2,,Ps)) = false [owise] .
***total compliance between two policy sets
op totalCompl : NePolicyList NePolicyList -> Bool .
eq totalCompl(P1, Ps1) = if complywithset( P1, Ps1) then true else false fi .
eq totalCompl((P1,,P2), Ps1) = if complywithset( P1, Ps1) and complywithset( P2, Ps1) == true  then true else false fi .
ceq totalCompl((P1,,P2,,Ps), Ps1) = true if complywithset( P1, Ps1) == true  /\  complywithset( P2, Ps1)== true  /\  complywithset( Ps, Ps1) == true  .
eq totalCompl((P1,,P2,,Ps), Ps1) = false [owise] .

endfm

***This module declares example polcies to check the policy compliance.
fmod TESTING is
  including FILTERTREE .
  including POLICY .
  including COMPLIANCE .

  ops PE1 PE2 PE3 PE4 PE5 PE6 PE7 PL PL1 PL2 PL3 : -> Policy .

  eq PE1 = ( doctor with entityTr , (Use & Store) , (healthServ :\: marketing,admin) with purposeTr , 200 , Europe with locationTr ) .
  eq PE2 = ( (hospital :\: admin ) with entityTr , (Use & Store & Collect), treatm with purposeTr , 300 , Europe with locationTr ) .
  eq PE3 = ( doctor with entityTr , ( Use & Store & Transfer), (healthServ :\: marketing,billing) with purposeTr , 200  , Europe with locationTr) .

  eq PE4 = (doctor with entityTr , (Use & Store & Collect) , healthServ with purposeTr  , 200 ,Europe with locationTr ) .
  eq PE5 = ((hospital :\: marketing ) with entityTr ,( Use & Store & Transfer) , healthServ with purposeTr , 300 , Europe with locationTr ) .
  eq PE6 = (healthAsso with entityTr , (Use & Store & Collect) , treatm with purposeTr , 300 , Europe with locationTr ) .

  eq PL = ((hospital :\: admin ) with entityTr,(Use), treatm wrt purposeTr ,100 , Europe wrt locationTr ) .
  eq PL1 = (doctor with entityTr , (Use), spcltreatm with purposeTr ,100 , Europe with locationTr ) .
  eq PL2 = (doctor with entityTr , (Use & Store), spcltreatm with purposeTr ,100 , Europe with locationTr ) .
  eq PL3 = (others with entityTr , (Use & Store & Transfer), spcltreatm with purposeTr ,100 , Europe with locationTr ) .

endfm
